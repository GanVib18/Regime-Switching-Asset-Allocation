# -*- coding: utf-8 -*-
"""model_comparison.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10_TeEdNBZWTuawsTEHpdWgR-4uRHk6--

## Model Comparison

### Install Dependencies
"""

!pip install hmmlearn

"""### Import Libraries"""

import os
import warnings
warnings.filterwarnings("ignore")

import joblib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import seaborn as sns
from datetime import datetime
from hmmlearn.hmm import GaussianHMM
from sklearn.preprocessing import StandardScaler

"""### Configuration"""

INPUT_DATA    = "/content/data_with_regimes.csv"
INPUT_MODEL   = "/content/model_hmm.pkl"
INPUT_CLEAN   = "/content/cleaned_data.csv"
OUTPUT_DIR    = "/content"

INITIAL_CAPITAL     = 100_000.0
RISK_FREE_RATE      = 0.02
REBALANCE_THRESHOLD = 0.05
BID_ASK_SPREAD      = 0.0008
TRAIN_END           = "2023-12-31"

# Vol threshold for Strategy 2 (annualised) â€” above this = defensive
VOL_THRESHOLD = 0.20   # 20%

ETF_CONFIG = {
    "XIU.TO":   "iShares S&P/TSX 60 (XIU)",
    "VFV.TO":   "Vanguard S&P 500 Index (VFV)",
    "XEF.TO":   "iShares MSCI EAFE (XEF)",
    "XBB.TO":   "iShares Cdn Bond (XBB)",
    "CGL-C.TO": "iShares Gold Bullion (CGL)",
}
ALL_TICKERS    = list(ETF_CONFIG.keys())
EQUITY_TICKERS = ["XIU.TO", "VFV.TO", "XEF.TO"]
BOND_TICKERS   = ["XBB.TO"]
GOLD_TICKERS   = ["CGL-C.TO"]

# â”€â”€ Allocation rules (shared across HMM strategies) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Regime 0 = Bull, 1 = Normal, 2 = Crisis
TARGET_WEIGHTS_3R = {
    0: {"XIU.TO": 0.30, "VFV.TO": 0.25, "XEF.TO": 0.15,
        "XBB.TO": 0.20, "CGL-C.TO": 0.10},
    1: {"XIU.TO": 0.25, "VFV.TO": 0.20, "XEF.TO": 0.15,
        "XBB.TO": 0.28, "CGL-C.TO": 0.12},
    2: {"XIU.TO": 0.15, "VFV.TO": 0.13, "XEF.TO": 0.12,
        "XBB.TO": 0.40, "CGL-C.TO": 0.20},
}

# Vol threshold: aggressive (low vol) vs defensive (high vol)
TARGET_WEIGHTS_VOL = {
    "aggressive": {"XIU.TO": 0.30, "VFV.TO": 0.25, "XEF.TO": 0.15,
                   "XBB.TO": 0.20, "CGL-C.TO": 0.10},   # same as Bull
    "defensive":  {"XIU.TO": 0.15, "VFV.TO": 0.13, "XEF.TO": 0.12,
                   "XBB.TO": 0.40, "CGL-C.TO": 0.20},   # same as Crisis
}

# 2-Regime HMM: only Bull (0) and Crisis (1) â€” no Medium state
TARGET_WEIGHTS_2R = {
    0: {"XIU.TO": 0.30, "VFV.TO": 0.25, "XEF.TO": 0.15,
        "XBB.TO": 0.20, "CGL-C.TO": 0.10},   # Bull
    1: {"XIU.TO": 0.15, "VFV.TO": 0.13, "XEF.TO": 0.12,
        "XBB.TO": 0.40, "CGL-C.TO": 0.20},   # Crisis
}

# Static 60/40 (gold excluded for clean benchmark)
N_EQ  = len(EQUITY_TICKERS)
N_BND = len(BOND_TICKERS)
STATIC_WEIGHTS = {t: 0.60 / N_EQ  for t in EQUITY_TICKERS}
STATIC_WEIGHTS.update({t: 0.40 / N_BND for t in BOND_TICKERS})
STATIC_WEIGHTS.update({t: 0.00 for t in GOLD_TICKERS})

# Chart colours â€” one per strategy
STRATEGY_COLORS = {
    "3-Regime HMM":   "#2ECC71",   # green  â€” your main strategy
    "Vol Threshold":  "#3498DB",   # blue
    "2-Regime HMM":   "#F39C12",   # amber
    "60/40 Static":   "#95A5A6",   # grey
}
STRATEGY_STYLES = {
    "3-Regime HMM":  "-",
    "Vol Threshold": "--",
    "2-Regime HMM":  "-.",
    "60/40 Static":  ":",
}

STRESS_EVENTS = {
    "COVID":  ("2020-02-01", "2020-05-31"),
    "2022":   ("2022-01-01", "2022-12-31"),
}

"""### Helper Fn."""

def add_year_grid(ax: plt.Axes) -> None:
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y"))
    ax.xaxis.set_major_locator(mdates.YearLocator())
    ax.grid(alpha=0.3)
    plt.setp(ax.xaxis.get_majorticklabels(), rotation=0)


def annotate_stress(ax: plt.Axes, alpha: float = 0.08) -> None:
    for label, (start, end) in STRESS_EVENTS.items():
        ax.axvspan(pd.Timestamp(start), pd.Timestamp(end),
                   alpha=alpha, color="black", zorder=0)
        ymin, ymax = ax.get_ylim()
        mid = (ymin + ymax) / 2
        ax.text(pd.Timestamp(start), ymax * 0.98, label,
                fontsize=7, color="black", alpha=0.5, va="top", ha="left")


def performance_metrics(values: np.ndarray,
                        rf_annual: float = RISK_FREE_RATE,
                        n_rebalances: int = 0,
                        total_costs: float = 0.0) -> dict:
    """Standard performance metrics from a portfolio value array."""
    returns = pd.Series(values).pct_change().dropna()
    if len(returns) == 0:
        return {}
    total_return = (values[-1] - values[0]) / values[0]
    ann_return   = (1 + total_return) ** (252 / len(returns)) - 1
    ann_vol      = returns.std() * np.sqrt(252)
    sharpe       = (ann_return - rf_annual) / ann_vol if ann_vol > 0 else np.nan
    cumulative   = pd.Series(values)
    rolling_max  = cumulative.cummax()
    drawdown     = (cumulative - rolling_max) / rolling_max
    max_dd       = drawdown.min()
    calmar       = ann_return / abs(max_dd) if max_dd != 0 else np.nan
    win_rate     = (returns > 0).mean()
    return {
        "Total_Return":   total_return,
        "Ann_Return":     ann_return,
        "Ann_Vol":        ann_vol,
        "Sharpe_Ratio":   sharpe,
        "Max_Drawdown":   max_dd,
        "Calmar_Ratio":   calmar,
        "Win_Rate":       win_rate,
        "N_Rebalances":   n_rebalances,
        "Total_Costs":    total_costs,
        "Cost_Pct":       total_costs / values[-1] if values[-1] > 0 else 0,
    }


def run_backtest(dates: pd.DatetimeIndex,
                 returns_df: pd.DataFrame,
                 weight_series: list,        # list of dicts {ticker: weight} per day
                 label: str) -> tuple:
    """
    Generic backtest engine.
    weight_series: list of length len(dates), each element is target weight dict.
    Returns (values array, n_rebalances, total_costs).
    """
    n_days = len(dates)
    values = np.zeros(n_days)
    holdings = {t: INITIAL_CAPITAL * weight_series[0].get(t, 0.0)
                for t in ALL_TICKERS}
    values[0]     = INITIAL_CAPITAL
    total_costs   = 0.0
    n_rebalances  = 0
    current_w     = weight_series[0].copy()

    for i in range(1, n_days):
        date = dates[i]

        # Apply returns
        pv = 0.0
        for t in ALL_TICKERS:
            ret = returns_df.loc[date, f"{t}_Return"] \
                  if f"{t}_Return" in returns_df.columns else 0.0
            if pd.isna(ret):
                ret = 0.0
            holdings[t] *= (1 + ret)
            pv += holdings[t]
        values[i] = pv

        # Check drift vs today's target
        target_w = weight_series[i]
        actual_w = {t: holdings[t] / pv if pv > 0 else 0.0 for t in ALL_TICKERS}
        max_drift = max(abs(actual_w.get(t, 0) - target_w.get(t, 0))
                        for t in ALL_TICKERS)

        if max_drift > REBALANCE_THRESHOLD:
            cost = 0.0
            for t in ALL_TICKERS:
                trade_val = abs(pv * target_w.get(t, 0.0) - holdings[t])
                cost += trade_val * BID_ASK_SPREAD
                holdings[t] = pv * target_w.get(t, 0.0)
            # Deduct cost proportionally
            scale = (pv - cost) / pv if pv > 0 else 1.0
            for t in ALL_TICKERS:
                holdings[t] *= scale
            values[i]    = sum(holdings.values())
            total_costs  += cost
            n_rebalances += 1
            current_w     = target_w.copy()

    print(f"       {label:<22}: {n_rebalances:>3} rebalances  "
          f"costs ${total_costs:.2f}  "
          f"final ${values[-1]:,.0f}")
    return values, n_rebalances, total_costs

"""### Load Data & 3-Regime Model"""

print("\n[1/6]  Loading data and 3-regime model ...")

master = pd.read_csv(INPUT_DATA, index_col="Date", parse_dates=True)
master.sort_index(inplace=True)

bundle         = joblib.load(INPUT_MODEL)
hmm3           = bundle["hmm"]
scaler3        = bundle["scaler"]
state_to_regime= bundle["state_to_regime"]
feature_cols   = bundle["feature_cols"]
n_regimes      = bundle["n_regimes"]   # should be 3

# Reconstruct ordered transition matrix for reference
ordered_states = sorted(state_to_regime, key=state_to_regime.get)
trans3 = np.zeros((n_regimes, n_regimes))
for nf, of in enumerate(ordered_states):
    for nt, ot in enumerate(ordered_states):
        trans3[nf, nt] = hmm3.transmat_[of, ot]

p_cols = [f"P_Regime{r}" for r in range(n_regimes)]

print(f"       Loaded: {master.shape[0]} rows, {n_regimes}-regime HMM")
print(f"       Features: {feature_cols}")

"""### Fit 2-Regime HMM"""

print("\n[2/6]  Fitting 2-regime HMM (train only) ...")

# Prepare feature matrix â€” same features as 3-regime model
missing_feat = [c for c in feature_cols if c not in master.columns]
if missing_feat:
    raise KeyError(f"Features missing from data: {missing_feat}")

data_feat = master[feature_cols].dropna()
train_mask = data_feat.index <= TRAIN_END
X_train_raw = data_feat.loc[train_mask].values

# Fit a fresh scaler on training data (same procedure as Phase 2)
scaler2 = StandardScaler()
X_train_sc2 = scaler2.fit_transform(X_train_raw)

# Multiple restarts â€” pick best log-likelihood
N_INIT_2R  = 30
best2, best_ll2 = None, -np.inf
for i in range(N_INIT_2R):
    m = GaussianHMM(n_components=2, covariance_type="full",
                    n_iter=2000, random_state=42 + i,
                    tol=1e-5, verbose=False)
    try:
        m.fit(X_train_sc2)
        ll = m.score(X_train_sc2)
        if ll > best_ll2:
            best_ll2, best2 = ll, m
    except Exception:
        pass

if best2 is None:
    raise RuntimeError("2-regime HMM failed to converge.")
print(f"       2-regime HMM converged  log-likelihood: {best_ll2:.4f}")

# Decode 2-regime labels across full dataset
X_all_sc2 = scaler2.transform(data_feat.values)
_, states2 = best2.decode(X_all_sc2, algorithm="viterbi")
post2      = best2.predict_proba(X_all_sc2)

# Semantically label: lower vol = regime 0 (Bull), higher vol = regime 1 (Crisis)
vol_idx = feature_cols.index("Market_RolVol20")
vol_raw = X_train_raw[:, vol_idx]

# states2 is a numpy array over the full dataset; slice to training rows only
# using a plain boolean numpy array (not a pandas Series)
train_mask_np = np.asarray(train_mask, dtype=bool)  # works whether pandas or numpy
states2_train = states2[train_mask_np]              # HMM states on train set only

state_vol = {s: vol_raw[states2_train == s].mean()
             for s in [0, 1]}
low_state  = min(state_vol, key=state_vol.get)     # low vol  = Bull
high_state = 1 - low_state                         # high vol = Crisis

# Remap: low_state â†’ 0 (Bull), high_state â†’ 1 (Crisis)
regime2_series = pd.Series(
    np.where(states2 == low_state, 0, 1),
    index=data_feat.index
)
# Posterior probability of being in Crisis (state 1)
p_crisis2 = pd.Series(
    post2[:, high_state],
    index=data_feat.index
)

print(f"       2-regime breakdown: "
      f"Bull={( regime2_series==0).mean():.1%}  "
      f"Crisis={(regime2_series==1).mean():.1%}")

"""### Build weight series"""

print("\n[3/6]  Building daily weight series for all strategies ...")

dates  = master.index
n_days = len(dates)

# Helper: normalise a weight dict to sum to 1
def norm(w: dict) -> dict:
    s = sum(w.values())
    return {t: v / s for t, v in w.items()} if s > 0 else w


# â”€â”€ Strategy 1: 3-Regime HMM (soft posterior allocation) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def soft_weights_3r(posterior: np.ndarray) -> dict:
    w = {t: 0.0 for t in ALL_TICKERS}
    for r in range(n_regimes):
        for t, wt in TARGET_WEIGHTS_3R[r].items():
            w[t] += posterior[r] * wt
    return norm(w)

weights_3r = []
for i, date in enumerate(dates):
    post = np.array([master.loc[date, f"P_Regime{r}"]
                     if f"P_Regime{r}" in master.columns else 0.0
                     for r in range(n_regimes)])
    post = np.nan_to_num(post)
    if post.sum() == 0:
        post[1] = 1.0   # default to Normal
    weights_3r.append(soft_weights_3r(post))
print("       Strategy 1 (3-Regime HMM): weight series built")


# â”€â”€ Strategy 2: Volatility Threshold â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Uses Market_RolVol20 from cleaned_data / data_with_regimes
# If vol > VOL_THRESHOLD â†’ defensive, else â†’ aggressive
# Strictly uses data available on each day (no look-ahead)
weights_vol = []
for date in dates:
    vol = master.loc[date, "Market_RolVol20"] \
          if "Market_RolVol20" in master.columns else np.nan
    if pd.isna(vol):
        vol = 0.12   # fallback to "normal" vol
    mode = "defensive" if vol > VOL_THRESHOLD else "aggressive"
    weights_vol.append(norm(TARGET_WEIGHTS_VOL[mode].copy()))
print("       Strategy 2 (Vol Threshold): weight series built")


# â”€â”€ Strategy 3: 2-Regime HMM (soft posterior) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def soft_weights_2r(p_crisis: float) -> dict:
    """Blend Bull and Crisis weights by crisis posterior probability."""
    p_bull = 1.0 - p_crisis
    w = {}
    for t in ALL_TICKERS:
        w[t] = (p_bull   * TARGET_WEIGHTS_2R[0].get(t, 0.0) +
                p_crisis * TARGET_WEIGHTS_2R[1].get(t, 0.0))
    return norm(w)

weights_2r = []
for date in dates:
    if date in p_crisis2.index:
        pc = p_crisis2.loc[date]
    else:
        pc = 0.0   # default to bull if date outside 2-regime model range
    weights_2r.append(soft_weights_2r(float(pc)))
print("       Strategy 3 (2-Regime HMM): weight series built")


# â”€â”€ Strategy 4: Static 60/40 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
weights_static = [norm(STATIC_WEIGHTS.copy())] * n_days
print("       Strategy 4 (60/40 Static): weight series built")

"""### Run Backtests"""

print("\n[4/6]  Running backtests (identical engine, same costs) ...")

vals_3r,     rb_3r,     costs_3r     = run_backtest(dates, master, weights_3r,     "3-Regime HMM")
vals_vol,    rb_vol,    costs_vol    = run_backtest(dates, master, weights_vol,    "Vol Threshold")
vals_2r,     rb_2r,     costs_2r     = run_backtest(dates, master, weights_2r,     "2-Regime HMM")
vals_static, rb_static, costs_static = run_backtest(dates, master, weights_static, "60/40 Static")

"""### Compute performance metrics"""

print("\n[5/6]  Computing performance metrics ...")

results = {
    "3-Regime HMM":  performance_metrics(vals_3r,     n_rebalances=rb_3r,     total_costs=costs_3r),
    "Vol Threshold": performance_metrics(vals_vol,    n_rebalances=rb_vol,    total_costs=costs_vol),
    "2-Regime HMM":  performance_metrics(vals_2r,     n_rebalances=rb_2r,     total_costs=costs_2r),
    "60/40 Static":  performance_metrics(vals_static, n_rebalances=rb_static, total_costs=costs_static),
}

# Index all value series (base = 100) for charting
idx_vals = {
    "3-Regime HMM":  vals_3r     / vals_3r[0]     * 100,
    "Vol Threshold": vals_vol    / vals_vol[0]    * 100,
    "2-Regime HMM":  vals_2r     / vals_2r[0]    * 100,
    "60/40 Static":  vals_static / vals_static[0] * 100,
}

# Drawdown series for each strategy
dd_vals = {}
for name, vals in [("3-Regime HMM", vals_3r), ("Vol Threshold", vals_vol),
                    ("2-Regime HMM", vals_2r), ("60/40 Static", vals_static)]:
    s = pd.Series(vals)
    dd_vals[name] = (s / s.cummax() - 1).values

# â”€â”€ Print comparison table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
metrics_display = [
    ("Total Return",  "Total_Return",  True),
    ("Ann. Return",   "Ann_Return",    True),
    ("Ann. Vol",      "Ann_Vol",       True),
    ("Sharpe Ratio",  "Sharpe_Ratio",  False),
    ("Max Drawdown",  "Max_Drawdown",  True),
    ("Calmar Ratio",  "Calmar_Ratio",  False),
    ("Win Rate",      "Win_Rate",      True),
    ("# Rebalances",  "N_Rebalances",  False),
    ("Total Costs $", "Total_Costs",   False),
]

strategies = ["3-Regime HMM", "Vol Threshold", "2-Regime HMM", "60/40 Static"]
col_w = 16

print(f"\n       {'Metric':<18}" +
      "".join(f"  {s:>{col_w}}" for s in strategies))
print("       " + "-" * (18 + (col_w + 2) * len(strategies)))

table_rows = []
for label, key, is_pct in metrics_display:
    row = {"Metric": label}
    line = f"       {label:<18}"
    for s in strategies:
        v = results[s].get(key, np.nan)
        row[s] = v
        if key in ("N_Rebalances",):
            line += f"  {int(v):>{col_w}}"
        elif key == "Total_Costs":
            line += f"  {'$' + f'{v:.2f}':>{col_w}}"
        elif is_pct:
            line += f"  {v:>{col_w}.1%}"
        else:
            line += f"  {v:>{col_w}.3f}"
    print(line)
    table_rows.append(row)

results_df = pd.DataFrame(table_rows).set_index("Metric")
results_df.to_csv(os.path.join(OUTPUT_DIR, "comparison_results.csv"))
print(f"\n       OK - comparison_results.csv")

"""### Charts"""

print("\n[6/6]  Generating charts ...")


# â”€â”€ Chart 1: Cumulative Returns (all 4 strategies) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
fig, axes = plt.subplots(2, 1, figsize=(14, 9),
                          gridspec_kw={"height_ratios": [2.5, 1]},
                          sharex=True)

ax0 = axes[0]
for name in strategies:
    ax0.plot(dates, idx_vals[name],
             color=STRATEGY_COLORS[name],
             linestyle=STRATEGY_STYLES[name],
             linewidth=2.0 if name == "3-Regime HMM" else 1.4,
             label=name,
             zorder=3 if name == "3-Regime HMM" else 2)

ax0.set_title("Strategy Comparison â€” Cumulative Returns (Indexed, Base = 100)",
              fontsize=13, fontweight="bold")
ax0.set_ylabel("Indexed Value (Start = 100)")
ax0.legend(loc="upper left", fontsize=9)
ax0.grid(alpha=0.3)
annotate_stress(ax0)

# Final value labels
for name in strategies:
    final_idx = idx_vals[name][-1]
    final_val = (final_idx / 100) * INITIAL_CAPITAL
    ax0.annotate(f"{final_idx:.0f}",
                 xy=(dates[-1], final_idx),
                 xytext=(5, 0), textcoords="offset points",
                 fontsize=8, color=STRATEGY_COLORS[name],
                 fontweight="bold" if name == "3-Regime HMM" else "normal")

# Bottom panel: drawdown
ax1 = axes[1]
for name in strategies:
    ax1.plot(dates, dd_vals[name] * 100,
             color=STRATEGY_COLORS[name],
             linestyle=STRATEGY_STYLES[name],
             linewidth=1.8 if name == "3-Regime HMM" else 1.2,
             label=name, alpha=0.9)

ax1.set_ylabel("Drawdown (%)")
ax1.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: f"{x:.0f}%"))
ax1.legend(loc="lower right", fontsize=7, ncol=2)
add_year_grid(ax1)
annotate_stress(ax1)

plt.tight_layout()
fig.savefig(os.path.join(OUTPUT_DIR, "chart_comparison_cumulative.png"),
            dpi=150, bbox_inches="tight")
plt.close()
print("       OK - chart_comparison_cumulative.png")


# â”€â”€ Chart 2: Metrics Bar Chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
key_metrics = [
    ("Sharpe Ratio",  "Sharpe_Ratio",  False, "Sharpe Ratio\n(higher = better)"),
    ("Ann. Return",   "Ann_Return",    True,  "Annualised Return\n(higher = better)"),
    ("Max Drawdown",  "Max_Drawdown",  True,  "Max Drawdown\n(less negative = better)"),
    ("Calmar Ratio",  "Calmar_Ratio",  False, "Calmar Ratio\n(higher = better)"),
]

fig, axes = plt.subplots(1, 4, figsize=(16, 5))
x = np.arange(len(strategies))
bar_colors = [STRATEGY_COLORS[s] for s in strategies]

for ax, (label, key, is_pct, title) in zip(axes, key_metrics):
    vals_bar = [results[s].get(key, np.nan) for s in strategies]
    bars = ax.bar(x, vals_bar, color=bar_colors, edgecolor="white",
                  linewidth=0.8, width=0.6)

    # Highlight best bar with a border
    best_idx = (np.argmax(vals_bar) if key != "Max_Drawdown"
                else np.argmax(vals_bar))   # max dd: least negative = best
    if key == "Max_Drawdown":
        best_idx = np.argmax(vals_bar)      # closest to zero
    bars[best_idx].set_edgecolor("black")
    bars[best_idx].set_linewidth(2.5)

    ax.axhline(0, color="black", linewidth=0.8)
    ax.set_title(title, fontsize=10, fontweight="bold")
    ax.set_xticks(x)
    ax.set_xticklabels([s.replace(" ", "\n") for s in strategies],
                        fontsize=8)
    ax.grid(axis="y", alpha=0.3)
    ax.spines[["top", "right"]].set_visible(False)

    if is_pct:
        ax.yaxis.set_major_formatter(
            plt.FuncFormatter(lambda v, _: f"{v:.0%}"))

    # Value labels on bars
    for bar, v in zip(bars, vals_bar):
        fmt = f"{v:.1%}" if is_pct else f"{v:.3f}"
        ypos = bar.get_height() + (0.001 if bar.get_height() >= 0 else -0.005)
        ax.text(bar.get_x() + bar.get_width() / 2, ypos,
                fmt, ha="center", va="bottom", fontsize=8,
                fontweight="bold")

fig.suptitle("Strategy Comparison â€” Key Performance Metrics",
             fontsize=13, fontweight="bold", y=1.02)
plt.tight_layout()
fig.savefig(os.path.join(OUTPUT_DIR, "chart_comparison_metrics.png"),
            dpi=150, bbox_inches="tight")
plt.close()
print("       OK - chart_comparison_metrics.png")


# â”€â”€ Chart 3: Sharpe Ratio Comparison (standalone â€” the money slide) â”€â”€â”€â”€â”€â”€
fig, ax = plt.subplots(figsize=(9, 5))
sharpe_vals = [results[s]["Sharpe_Ratio"] for s in strategies]
bars = ax.bar(strategies, sharpe_vals,
              color=bar_colors, edgecolor="white", linewidth=0.8, width=0.5)

# Bold border on best
best_sharpe_idx = int(np.argmax(sharpe_vals))
bars[best_sharpe_idx].set_edgecolor("black")
bars[best_sharpe_idx].set_linewidth(2.5)

# Difference vs 60/40 annotations
base_sharpe = results["60/40 Static"]["Sharpe_Ratio"]
for bar, s, v in zip(bars, strategies, sharpe_vals):
    diff = v - base_sharpe
    sign = "+" if diff >= 0 else ""
    label = f"{v:.3f}\n({sign}{diff:.3f} vs 60/40)"
    ax.text(bar.get_x() + bar.get_width() / 2,
            bar.get_height() + 0.005,
            label, ha="center", va="bottom", fontsize=9,
            fontweight="bold" if s == "3-Regime HMM" else "normal")

ax.axhline(base_sharpe, color="#95A5A6", linestyle="--",
           linewidth=1.2, label=f"60/40 baseline ({base_sharpe:.3f})")
ax.set_title("Sharpe Ratio Comparison â€” All Strategies\n"
             "(Black border = best performer)",
             fontsize=13, fontweight="bold")
ax.set_ylabel("Sharpe Ratio (annualised, rf=2%)")
ax.legend(fontsize=9)
ax.grid(axis="y", alpha=0.3)
ax.spines[["top", "right"]].set_visible(False)
ax.set_ylim(0, max(sharpe_vals) * 1.25)
plt.tight_layout()
fig.savefig(os.path.join(OUTPUT_DIR, "chart_comparison_sharpe.png"),
            dpi=150, bbox_inches="tight")
plt.close()
print("       OK - chart_comparison_sharpe.png")


# â”€â”€ Chart 4: Rebalancing Activity & Costs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
fig, axes = plt.subplots(1, 2, figsize=(11, 4))

# Panel 1: number of rebalances
rb_counts = [results[s]["N_Rebalances"] for s in strategies]
axes[0].bar(strategies, rb_counts, color=bar_colors,
            edgecolor="white", linewidth=0.8, width=0.5)
for bar, v in zip(axes[0].patches, rb_counts):
    axes[0].text(bar.get_x() + bar.get_width() / 2,
                 bar.get_height() + 0.3,
                 str(int(v)), ha="center", va="bottom", fontsize=9,
                 fontweight="bold")
axes[0].set_title("Rebalancing Events\n(full backtest period)",
                  fontsize=11, fontweight="bold")
axes[0].set_ylabel("Number of Rebalances")
axes[0].set_xticklabels([s.replace(" ", "\n") for s in strategies], fontsize=8)
axes[0].grid(axis="y", alpha=0.3)
axes[0].spines[["top", "right"]].set_visible(False)

# Panel 2: total transaction costs
cost_vals = [results[s]["Total_Costs"] for s in strategies]
axes[1].bar(strategies, cost_vals, color=bar_colors,
            edgecolor="white", linewidth=0.8, width=0.5)
for bar, v in zip(axes[1].patches, cost_vals):
    axes[1].text(bar.get_x() + bar.get_width() / 2,
                 bar.get_height() + 1,
                 f"${v:.0f}", ha="center", va="bottom", fontsize=9,
                 fontweight="bold")
axes[1].set_title("Total Transaction Costs\n(8 bps bid-ask per trade)",
                  fontsize=11, fontweight="bold")
axes[1].set_ylabel("Total Cost ($)")
axes[1].set_xticklabels([s.replace(" ", "\n") for s in strategies], fontsize=8)
axes[1].grid(axis="y", alpha=0.3)
axes[1].spines[["top", "right"]].set_visible(False)

fig.suptitle("Trading Activity â€” Rebalances & Costs",
             fontsize=12, fontweight="bold", y=1.02)
plt.tight_layout()
fig.savefig(os.path.join(OUTPUT_DIR, "chart_comparison_costs.png"),
            dpi=150, bbox_inches="tight")
plt.close()
print("       OK - chart_comparison_costs.png")

"""### Summary"""

summary_path = os.path.join(OUTPUT_DIR, "comparison_summary.txt")
with open(summary_path, "w") as f:
    f.write("REGIME-SWITCHING ASSET ALLOCATION â€” PHASE 6 MODEL COMPARISON\n")
    f.write(f"Generated : {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
    f.write("=" * 70 + "\n\n")

    f.write("STRATEGIES COMPARED\n")
    f.write("  1. 3-Regime HMM  : Gaussian HMM (3 states), soft posterior allocation\n")
    f.write("  2. Vol Threshold : If Market_RolVol20 > 20% â†’ defensive, else aggressive\n")
    f.write("  3. 2-Regime HMM  : Gaussian HMM (2 states, bull vs crisis only)\n")
    f.write("  4. 60/40 Static  : Never rebalance away from 60% equity / 40% bond\n\n")

    f.write("BACKTEST PARAMETERS\n")
    f.write(f"  Initial capital     : ${INITIAL_CAPITAL:,.0f}\n")
    f.write(f"  Transaction cost    : {BID_ASK_SPREAD*10000:.0f} bps per trade (bid-ask spread)\n")
    f.write(f"  Rebalance threshold : {REBALANCE_THRESHOLD:.0%} drift\n")
    f.write(f"  Risk-free rate      : {RISK_FREE_RATE:.0%} (Canadian T-bill approx)\n\n")

    f.write("PERFORMANCE COMPARISON\n")
    col = 16
    header = f"  {'Metric':<18}" + "".join(f"  {s:>{col}}" for s in strategies)
    f.write(header + "\n")
    f.write("  " + "-" * (18 + (col + 2) * len(strategies)) + "\n")

    for label, key, is_pct, *_ in [
        ("Total Return",  "Total_Return",  True),
        ("Ann. Return",   "Ann_Return",    True),
        ("Ann. Vol",      "Ann_Vol",       True),
        ("Sharpe Ratio",  "Sharpe_Ratio",  False),
        ("Max Drawdown",  "Max_Drawdown",  True),
        ("Calmar Ratio",  "Calmar_Ratio",  False),
        ("Win Rate",      "Win_Rate",      True),
        ("# Rebalances",  "N_Rebalances",  False),
        ("Total Costs",   "Total_Costs",   False),
    ]:
        line = f"  {label:<18}"
        for s in strategies:
            v = results[s].get(key, np.nan)
            if key == "N_Rebalances":
                line += f"  {int(v):>{col}}"
            elif key == "Total_Costs":
                line += f"  {'$'+f'{v:.2f}':>{col}}"
            elif is_pct:
                line += f"  {v:>{col}.1%}"
            else:
                line += f"  {v:>{col}.3f}"
        f.write(line + "\n")

    f.write("\nKEY FINDINGS\n")
    best_sharpe = max(strategies, key=lambda s: results[s]["Sharpe_Ratio"])
    best_dd     = max(strategies, key=lambda s: results[s]["Max_Drawdown"])
    f.write(f"  Best Sharpe Ratio : {best_sharpe} "
            f"({results[best_sharpe]['Sharpe_Ratio']:.3f})\n")
    f.write(f"  Best Max Drawdown : {best_dd} "
            f"({results[best_dd]['Max_Drawdown']:.1%})\n")
    sharpe_vs_static = (results["3-Regime HMM"]["Sharpe_Ratio"] -
                        results["60/40 Static"]["Sharpe_Ratio"])
    sharpe_vs_vol    = (results["3-Regime HMM"]["Sharpe_Ratio"] -
                        results["Vol Threshold"]["Sharpe_Ratio"])
    sharpe_vs_2r     = (results["3-Regime HMM"]["Sharpe_Ratio"] -
                        results["2-Regime HMM"]["Sharpe_Ratio"])
    f.write(f"\n  3-Regime HMM Sharpe vs 60/40 Static : {sharpe_vs_static:+.3f}\n")
    f.write(f"  3-Regime HMM Sharpe vs Vol Threshold : {sharpe_vs_vol:+.3f}\n")
    f.write(f"  3-Regime HMM Sharpe vs 2-Regime HMM : {sharpe_vs_2r:+.3f}\n")

print(f"       OK - comparison_summary.txt")

















# -*- coding: utf-8 -*-
"""
Regime-Switching Asset Allocation - OPTIMIZED VERSION
Implements regime-specific mean-variance portfolio optimization
"""

import os
import warnings
warnings.filterwarnings("ignore")

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import seaborn as sns
from datetime import datetime
from hmmlearn.hmm import GaussianHMM
from sklearn.preprocessing import StandardScaler
from scipy.optimize import minimize

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Input files (you'll need to provide these paths)
INPUT_DATA = "data_with_regimes.csv"  # Should have regime predictions
INPUT_MODEL = "model_hmm.pkl"
INPUT_CLEAN = "cleaned_data.csv"
OUTPUT_DIR    = "/content"

INITIAL_CAPITAL = 100_000.0
RISK_FREE_RATE = 0.02
REBALANCE_THRESHOLD = 0.05
BID_ASK_SPREAD = 0.0008
TRAIN_END = "2023-12-31"
VOL_THRESHOLD = 0.20  # 20% annualized

ETF_CONFIG = {
    "XIU.TO": "iShares S&P/TSX 60 (XIU)",
    "VFV.TO": "Vanguard S&P 500 Index (VFV)",
    "XEF.TO": "iShares MSCI EAFE (XEF)",
    "XBB.TO": "iShares Cdn Bond (XBB)",
    "CGL-C.TO": "iShares Gold Bullion (CGL)",
}
ALL_TICKERS = list(ETF_CONFIG.keys())
EQUITY_TICKERS = ["XIU.TO", "VFV.TO", "XEF.TO"]
BOND_TICKERS = ["XBB.TO"]
GOLD_TICKERS = ["CGL-C.TO"]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# REGIME-SPECIFIC PORTFOLIO OPTIMIZATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def calculate_regime_statistics(returns_df, regime_col, tickers, n_regimes=3):
    """
    Calculate mean returns and covariance matrices for each regime.

    Returns:
        regime_stats: dict with keys 0,1,2 containing {'mean': array, 'cov': matrix}
    """
    regime_stats = {}

    for regime in range(n_regimes):
        # Filter data for this regime
        regime_mask = returns_df[regime_col] == regime
        regime_data = returns_df[regime_mask]

        # Extract return columns
        return_cols = [f"{t}_Return" for t in tickers]
        regime_returns = regime_data[return_cols].dropna()

        if len(regime_returns) < 5:  # Need minimum observations
            print(f"Warning: Regime {regime} has only {len(regime_returns)} observations")
            # Use overall statistics as fallback
            regime_returns = returns_df[return_cols].dropna()

        # Calculate statistics
        mean_returns = regime_returns.mean().values
        cov_matrix = regime_returns.cov().values

        # Annualize (assuming daily returns)
        mean_returns_annual = mean_returns * 252
        cov_matrix_annual = cov_matrix * 252

        regime_stats[regime] = {
            'mean': mean_returns_annual,
            'cov': cov_matrix_annual,
            'n_obs': len(regime_returns),
            'avg_vol': np.sqrt(np.diag(cov_matrix_annual)).mean()
        }

        print(f"Regime {regime}: {len(regime_returns)} obs, avg vol = {regime_stats[regime]['avg_vol']:.1%}")

    return regime_stats


def optimize_portfolio_weights(mean_returns, cov_matrix, risk_aversion=1.0,
                                min_weight=0.0, max_weight=0.5):
    """
    Solve for optimal portfolio weights using mean-variance optimization.

    Objective: maximize (expected return - risk_aversion * variance)

    Args:
        mean_returns: array of expected returns (annualized)
        cov_matrix: covariance matrix (annualized)
        risk_aversion: controls risk/return tradeoff (higher = more conservative)
        min_weight: minimum weight per asset
        max_weight: maximum weight per asset

    Returns:
        optimal_weights: array of weights summing to 1
    """
    n_assets = len(mean_returns)

    # Objective function: negative of (return - risk_aversion * variance)
    def objective(w):
        portfolio_return = np.dot(w, mean_returns)
        portfolio_variance = np.dot(w, np.dot(cov_matrix, w))
        return -(portfolio_return - risk_aversion * portfolio_variance)

    # Constraints: weights sum to 1
    constraints = {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0}

    # Bounds: each weight between min_weight and max_weight
    bounds = tuple((min_weight, max_weight) for _ in range(n_assets))

    # Initial guess: equal weights
    initial_weights = np.ones(n_assets) / n_assets

    # Optimize
    result = minimize(
        objective,
        initial_weights,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints,
        options={'maxiter': 1000}
    )

    if not result.success:
        print(f"Warning: Optimization failed: {result.message}")
        return initial_weights

    return result.x


def create_regime_optimized_weights(regime_stats, tickers, risk_aversion_by_regime):
    """
    Create optimal weights for each regime using mean-variance optimization.

    Args:
        regime_stats: dict from calculate_regime_statistics
        tickers: list of ticker symbols
        risk_aversion_by_regime: dict mapping regime -> risk aversion parameter

    Returns:
        target_weights: dict mapping regime -> {ticker: weight}
    """
    target_weights = {}

    for regime, risk_aversion in risk_aversion_by_regime.items():
        stats = regime_stats[regime]

        # Optimize
        optimal_w = optimize_portfolio_weights(
            mean_returns=stats['mean'],
            cov_matrix=stats['cov'],
            risk_aversion=risk_aversion,
            min_weight=0.05,  # At least 5% per asset
            max_weight=0.35   # At most 50% per asset
        )

        # Convert to dict
        weights_dict = {ticker: w for ticker, w in zip(tickers, optimal_w)}
        target_weights[regime] = weights_dict

        # Print summary
        equity_weight = sum(weights_dict[t] for t in EQUITY_TICKERS)
        bond_weight = sum(weights_dict[t] for t in BOND_TICKERS)
        gold_weight = sum(weights_dict[t] for t in GOLD_TICKERS)

        print(f"\nRegime {regime} (risk_aversion={risk_aversion}):")
        print(f"  Equity: {equity_weight:.1%} | Bonds: {bond_weight:.1%} | Gold: {gold_weight:.1%}")
        for t, w in weights_dict.items():
            print(f"    {t}: {w:.1%}")

    return target_weights


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BACKTESTING ENGINE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def performance_metrics(values: np.ndarray, rf_annual: float = RISK_FREE_RATE,
                        n_rebalances: int = 0, total_costs: float = 0.0) -> dict:
    """Calculate standard performance metrics from portfolio value array."""
    returns = pd.Series(values).pct_change().dropna()
    if len(returns) == 0:
        return {}

    total_return = (values[-1] - values[0]) / values[0]
    ann_return = (1 + total_return) ** (252 / len(returns)) - 1
    ann_vol = returns.std() * np.sqrt(252)
    sharpe = (ann_return - rf_annual) / ann_vol if ann_vol > 0 else np.nan

    cumulative = pd.Series(values)
    rolling_max = cumulative.cummax()
    drawdown = (cumulative - rolling_max) / rolling_max
    max_dd = drawdown.min()
    calmar = ann_return / abs(max_dd) if max_dd != 0 else np.nan
    win_rate = (returns > 0).mean()

    return {
        "Total_Return": total_return,
        "Ann_Return": ann_return,
        "Ann_Vol": ann_vol,
        "Sharpe_Ratio": sharpe,
        "Max_Drawdown": max_dd,
        "Calmar_Ratio": calmar,
        "Win_Rate": win_rate,
        "N_Rebalances": n_rebalances,
        "Total_Costs": total_costs,
    }


def run_backtest(dates, returns_df, weight_series, label):
    """
    Generic backtest engine.

    Args:
        dates: DatetimeIndex of trading days
        returns_df: DataFrame with return columns
        weight_series: list of dicts {ticker: weight} for each day
        label: strategy name

    Returns:
        (values_array, n_rebalances, total_costs)
    """
    n_days = len(dates)
    values = np.zeros(n_days)
    holdings = {t: INITIAL_CAPITAL * weight_series[0].get(t, 0.0) for t in ALL_TICKERS}
    values[0] = INITIAL_CAPITAL
    total_costs = 0.0
    n_rebalances = 0

    for i in range(1, n_days):
        date = dates[i]

        # Apply returns
        pv = 0.0
        for t in ALL_TICKERS:
            ret = returns_df.loc[date, f"{t}_Return"] if f"{t}_Return" in returns_df.columns else 0.0
            if pd.isna(ret):
                ret = 0.0
            holdings[t] *= (1 + ret)
            pv += holdings[t]
        values[i] = pv

        # Check drift vs target
        target_w = weight_series[i]
        actual_w = {t: holdings[t] / pv if pv > 0 else 0.0 for t in ALL_TICKERS}
        max_drift = max(abs(actual_w.get(t, 0) - target_w.get(t, 0)) for t in ALL_TICKERS)

        if max_drift > REBALANCE_THRESHOLD:
            # Rebalance
            cost = 0.0
            for t in ALL_TICKERS:
                trade_val = abs(pv * target_w.get(t, 0.0) - holdings[t])
                cost += trade_val * BID_ASK_SPREAD
                holdings[t] = pv * target_w.get(t, 0.0)

            values[i] -= cost
            total_costs += cost
            n_rebalances += 1

            # Recalculate PV after costs
            pv = sum(holdings.values())
            values[i] = pv

    return values, n_rebalances, total_costs


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STRATEGY IMPLEMENTATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def build_3regime_optimized_weights(df, regime_col, target_weights_dict):
    """Build weight series using optimized regime-specific weights."""
    weight_series = []
    for idx, row in df.iterrows():
        regime = int(row[regime_col])
        weight_series.append(target_weights_dict[regime])
    return weight_series


def build_2regime_hmm_weights(returns_df, tickers, target_weights_2r):
    """Train 2-regime HMM and build weight series."""
    # Prepare features
    return_cols = [f"{t}_Return" for t in tickers]
    features = returns_df[return_cols + ["Market_RolVol20"]].dropna()

    # Standardize
    scaler = StandardScaler()
    X = scaler.fit_transform(features.values)

    # Train 2-state HMM
    model_2r = GaussianHMM(n_components=2, covariance_type="full",
                           n_iter=1000, random_state=42)
    model_2r.fit(X)

    # Predict regimes
    regimes_2r = model_2r.predict(X)

    # Identify which is bull vs crisis (higher vol = crisis)
    regime_vols = [features["Market_RolVol20"][regimes_2r == r].mean() for r in range(2)]
    bull_regime = 0 if regime_vols[0] < regime_vols[1] else 1
    crisis_regime = 1 - bull_regime

    # Build weight series
    weight_series = []
    for regime in regimes_2r:
        if regime == bull_regime:
            weight_series.append(target_weights_2r[0])
        else:
            weight_series.append(target_weights_2r[1])

    return weight_series, regimes_2r


def build_vol_threshold_weights(returns_df, target_weights_vol):
    """Build weight series using simple volatility threshold."""
    weight_series = []
    for idx, row in returns_df.iterrows():
        vol = row["Market_RolVol20"]
        if pd.isna(vol):
            weight_series.append(target_weights_vol["aggressive"])
        elif vol > VOL_THRESHOLD:
            weight_series.append(target_weights_vol["defensive"])
        else:
            weight_series.append(target_weights_vol["aggressive"])
    return weight_series


def build_static_weights(returns_df, static_weights):
    """Build weight series for static 60/40 portfolio."""
    return [static_weights.copy() for _ in range(len(returns_df))]


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VISUALIZATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def plot_cumulative_returns(results_dict, dates, output_dir):
    """Plot cumulative returns comparison."""
    fig, ax = plt.subplots(figsize=(14, 7))

    strategy_colors = {
        "3-Regime Optimized": "#2ECC71",
        "Vol Threshold": "#3498DB",
        "2-Regime HMM": "#F39C12",
        "60/40 Static": "#95A5A6",
    }

    for strategy, data in results_dict.items():
        values = data['values']
        ax.plot(dates, values, label=strategy,
                color=strategy_colors.get(strategy, "#000000"),
                linewidth=2.5 if "Optimized" in strategy else 1.5)

    ax.set_title("Cumulative Returns â€” All Strategies", fontsize=14, fontweight='bold')
    ax.set_ylabel("Portfolio Value ($)", fontsize=12)
    ax.set_xlabel("Date", fontsize=12)
    ax.legend(fontsize=10, loc='upper left')
    ax.grid(alpha=0.3)
    plt.tight_layout()

    fig.savefig(os.path.join(output_dir, "cumulative_returns_optimized.png"),
                dpi=150, bbox_inches='tight')
    plt.close()
    print("âœ“ Saved cumulative_returns_optimized.png")


def plot_metrics_comparison(results_dict, output_dir):
    """Plot key metrics bar chart."""
    strategies = list(results_dict.keys())
    metrics = ['Sharpe_Ratio', 'Ann_Return', 'Max_Drawdown', 'Calmar_Ratio']
    titles = ['Sharpe Ratio', 'Annual Return', 'Max Drawdown', 'Calmar Ratio']

    fig, axes = plt.subplots(1, 4, figsize=(16, 5))

    colors = ["#2ECC71", "#3498DB", "#F39C12", "#95A5A6"]

    for ax, metric, title in zip(axes, metrics, titles):
        vals = [results_dict[s]['metrics'][metric] for s in strategies]
        bars = ax.bar(range(len(strategies)), vals, color=colors,
                      edgecolor='white', linewidth=0.8)

        # Highlight best
        best_idx = np.argmax(vals) if metric != 'Max_Drawdown' else np.argmax(vals)
        bars[best_idx].set_edgecolor('black')
        bars[best_idx].set_linewidth(2.5)

        ax.set_title(title, fontsize=11, fontweight='bold')
        ax.set_xticks(range(len(strategies)))
        ax.set_xticklabels([s.replace(" ", "\n") for s in strategies], fontsize=8)
        ax.grid(axis='y', alpha=0.3)

        # Add value labels
        for bar, v in zip(bars, vals):
            if metric in ['Ann_Return', 'Max_Drawdown']:
                label = f"{v:.1%}"
            else:
                label = f"{v:.3f}"
            ax.text(bar.get_x() + bar.get_width() / 2,
                   bar.get_height() + 0.01,
                   label, ha='center', va='bottom', fontsize=9, fontweight='bold')

    fig.suptitle("Performance Metrics Comparison", fontsize=13, fontweight='bold')
    plt.tight_layout()
    fig.savefig(os.path.join(output_dir, "metrics_comparison_optimized.png"),
                dpi=150, bbox_inches='tight')
    plt.close()
    print("âœ“ Saved metrics_comparison_optimized.png")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN EXECUTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    print("=" * 80)
    print("REGIME-SWITCHING ASSET ALLOCATION â€” OPTIMIZED VERSION")
    print("Implementing regime-specific mean-variance portfolio optimization")
    print("=" * 80)

    # Load data
    print("\n[1/6] Loading data...")
    df = pd.read_csv(INPUT_DATA, parse_dates=['Date'], index_col='Date')

    # Calculate regime statistics on TRAINING data only
    print("\n[2/6] Calculating regime-specific statistics (training data only)...")
    train_df = df[df.index <= TRAIN_END]
    regime_stats = calculate_regime_statistics(
        returns_df=train_df,
        regime_col='Regime',
        tickers=ALL_TICKERS,
        n_regimes=3
    )

    # Optimize weights for each regime
    print("\n[3/6] Optimizing portfolio weights for each regime...")

    # Risk aversion parameters (higher = more conservative)
    # Regime 0 = Bull (low vol) â†’ lower risk aversion (more aggressive)
    # Regime 1 = Normal (medium vol) â†’ medium risk aversion
    # Regime 2 = Crisis (high vol) â†’ higher risk aversion (more defensive)
    risk_aversion_by_regime = {
        0: 1.0,   # Bull: willing to take risk
        1: 2.0,   # Normal: moderate
        2: 4.0,   # Crisis: very conservative
    }

    TARGET_WEIGHTS_3R_OPTIMIZED = create_regime_optimized_weights(
        regime_stats=regime_stats,
        tickers=ALL_TICKERS,
        risk_aversion_by_regime=risk_aversion_by_regime
    )

    # For comparison strategies, use simpler fixed weights
    # Vol threshold
    TARGET_WEIGHTS_VOL = {
        "aggressive": {"XIU.TO": 0.30, "VFV.TO": 0.25, "XEF.TO": 0.15,
                      "XBB.TO": 0.20, "CGL-C.TO": 0.10},
        "defensive": {"XIU.TO": 0.15, "VFV.TO": 0.13, "XEF.TO": 0.12,
                     "XBB.TO": 0.40, "CGL-C.TO": 0.20},
    }

    # 2-Regime HMM (also optimize these)
    regime_stats_2r = calculate_regime_statistics(
        returns_df=train_df,
        regime_col='Regime',  # We'll retrain this
        tickers=ALL_TICKERS,
        n_regimes=2
    )

    # Static 60/40
    STATIC_WEIGHTS = {t: 0.60 / len(EQUITY_TICKERS) for t in EQUITY_TICKERS}
    STATIC_WEIGHTS.update({t: 0.40 / len(BOND_TICKERS) for t in BOND_TICKERS})
    STATIC_WEIGHTS.update({t: 0.00 for t in GOLD_TICKERS})

    # Build weight series for all strategies
    print("\n[4/6] Building weight series for all strategies...")

    weight_series_3r_opt = build_3regime_optimized_weights(df, 'Regime', TARGET_WEIGHTS_3R_OPTIMIZED)
    weight_series_vol = build_vol_threshold_weights(df, TARGET_WEIGHTS_VOL)
    weight_series_static = build_static_weights(df, STATIC_WEIGHTS)

    # For 2-regime, we need to retrain (simplified version)
    TARGET_WEIGHTS_2R = {
        0: {"XIU.TO": 0.30, "VFV.TO": 0.25, "XEF.TO": 0.15,
            "XBB.TO": 0.20, "CGL-C.TO": 0.10},
        1: {"XIU.TO": 0.15, "VFV.TO": 0.13, "XEF.TO": 0.12,
            "XBB.TO": 0.40, "CGL-C.TO": 0.20},
    }
    weight_series_2r, _ = build_2regime_hmm_weights(df, ALL_TICKERS, TARGET_WEIGHTS_2R)

    # Run backtests
    print("\n[5/6] Running backtests...")
    dates = df.index

    strategies = {
        "3-Regime Optimized": weight_series_3r_opt,
        "Vol Threshold": weight_series_vol,
        "2-Regime HMM": weight_series_2r,
        "60/40 Static": weight_series_static,
    }

    results = {}
    for strategy_name, weight_series in strategies.items():
        print(f"  Running {strategy_name}...")
        values, n_reb, costs = run_backtest(dates, df, weight_series, strategy_name)
        metrics = performance_metrics(values, RISK_FREE_RATE, n_reb, costs)
        results[strategy_name] = {
            'values': values,
            'metrics': metrics,
        }

    # Print results
    print("\n[6/6] Results:")
    print("\n" + "=" * 90)
    print(f"{'Strategy':<25} {'Sharpe':>10} {'Ann Return':>12} {'Max DD':>10} {'# Reb':>8} {'Costs':>10}")
    print("=" * 90)
    for strategy_name, data in results.items():
        m = data['metrics']
        print(f"{strategy_name:<25} {m['Sharpe_Ratio']:>10.3f} {m['Ann_Return']:>11.1%} "
              f"{m['Max_Drawdown']:>10.1%} {m['N_Rebalances']:>8.0f} ${m['Total_Costs']:>9.0f}")
    print("=" * 90)

    # Find best
    best_strategy = max(results.keys(), key=lambda s: results[s]['metrics']['Sharpe_Ratio'])
    best_sharpe = results[best_strategy]['metrics']['Sharpe_Ratio']
    print(f"\nğŸ† BEST SHARPE RATIO: {best_strategy} ({best_sharpe:.3f})")

    # Improvement vs 60/40
    baseline_sharpe = results["60/40 Static"]['metrics']['Sharpe_Ratio']
    improvement = best_sharpe - baseline_sharpe
    improvement_pct = (improvement / baseline_sharpe) * 100
    print(f"   Improvement vs 60/40: +{improvement:.3f} ({improvement_pct:.1f}%)")

    # Create visualizations
    print("\n[Visualizations]")
    plot_cumulative_returns(results, dates, OUTPUT_DIR)
    plot_metrics_comparison(results, OUTPUT_DIR)

    print("\nâœ“ All done! Check output files in current directory.")

    return results


if __name__ == "__main__":
    results = main()

